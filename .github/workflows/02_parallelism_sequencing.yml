# Github Actions Example 2: Parallelism and Sequencing
# This demonstrates how jobs can run in parallel or sequencially.
# and how to control dependencies between jobs.

name: 02 - Parallelism and Sequencing

# Trigger: When this workflow runs
on:
  # Run on push ton main or develop branches
  push:
    branches: [ main, develop ]
  # On pull requests to main
  pull_request:
    branches: [ main ]
  # Allow manual triggering from GitHub UI
  workflow_dispatch:

# Jobs: Define what work to do
jobs:
  # Job 1: Preparation (runs first)
  preparation:
    runs-on: ubuntu-latest
    outputs:
      # Output that other jobs can use
      timestamp: ${{ steps.set_timestamp.outputs.timestamp }}
      build_number: ${{ steps.set_build_number.outputs.build_number }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Generate Timestamp
        id: set_timestamp
        run: echo "timestamp=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT

      - name: Generate Build Number
        id: set_build_number
        run: echo "build_number=${{ github.run_number }}" >> $GITHUB_OUTPUT

      - name: Show Preparation Info
        run: |
          echo "Preparation completed at: ${{ steps.set_timestamp.outputs.timestamp }}"
          echo "Build Number: ${{ steps.set_build_number.outputs.build_number }}"

  # Job 2: Unit Tests (runs un parallel after preparation)
  unit_tests:
    runs-on: ubuntu-latest
    needs: preparation # Waits for preparation to complete
    strategy:
      matrix:
        # Run tests on multiple Node.js versions in parallel
        node-version: [16, 18, 20]

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Simulate Unit Tests
        run: |
          echo "Running unit tests on Node.js version ${{ matrix.node-version }}"
          echo "Build number from preparation job: ${{ needs.preparation.outputs.build_number }}"
          sleep 5 # Simulate test execution time
          echo "Unit tests passed! âœ…"

  # Job 3: Integration Tests (runs in parallel with Unit Tests)
  integration_tests:
    runs-on: ubuntu-latest
    needs: preparation
    strategy:
      matrix:
        # Run on diferent operating systems in parallel
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Simulate integration tests
        run: |
          echo "Running integration tests on ${{ matrix.os }}"
          echo "Timestamp from preparation job: ${{ needs.preparation.outputs.timestamp }}"
          sleep 8 # Simulate longer test execution
          echo "Integration tests passed! âœ…"

  # Job 4: Code Quality Checks (runs in parallel with tests)
  code_quality:
    runs-on: ubuntu-latest
    needs: preparation

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Lint Check
        run: |
          echo "Running linting..."
          sleep 3
          echo "Linting passed! âœ…"

      - name: Security Scan
        run: |
          echo "Running security scan..."
          sleep 4
          echo "Security scan passed! âœ…"

      - name: Code Coverage
        run: |
          echo "Calculating code coverage..."
          sleep 2
          echo "Code coverage 95% âœ…"

  # Job 5: Build (waits for all parallel jobs to complete)
  build:
    runs-on: ubuntu-latest
    needs: [unit_tests, integration_tests, code_quality] # Waits for ALL to complete

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Build Application
        run: |
          echo "All tests and quality checks passed!"
          echo "Building application..."
          sleep 6
          echo "Build completed successfully! ðŸš€"